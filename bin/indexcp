#!/usr/bin/env node

// Set CLI mode for filesystem storage
process.env.INDEXCP_CLI_MODE = 'true';

const IndexCPClient = require('../lib/client');
const { IndexCPServer } = require('../lib/server');
const { createLogger } = require('../lib/logger');
const path = require('path');
const fs = require('fs');

const logger = createLogger({ prefix: '[IndexCP-CLI]' });

const args = process.argv.slice(2);
const command = args[0];

async function main() {
  if (!command) {
    showHelp();
    return;
  }

  // Check for cp-style command: indexcp file_to_upload http://localhost:3000
  // This is when first arg is a file path and second arg looks like a URL
  if (args.length >= 2 && 
      !['add', 'upload', 'server', 'ls', 'list', 'help', '--help', '-h'].includes(command) &&
      (args[1].startsWith('http://') || args[1].startsWith('https://'))) {
    // cp-style: first arg is file, second arg is server URL
    await handleCpStyle(args);
    return;
  }

  switch (command) {
    case 'add':
      await handleAdd(args.slice(1));
      break;
    case 'upload':
      await handleUpload(args.slice(1));
      break;
    case 'ls':
    case 'list':
      await handleList(args.slice(1));
      break;
    case 'server':
      await handleServer(args.slice(1));
      break;
    case 'help':
    case '--help':
    case '-h':
      showHelp();
      break;
    default:
      logger.error(`Unknown command: ${command}`);
      showHelp();
      process.exit(1);
  }
}

async function handleCpStyle(args) {
  const filePath = args[0];
  const serverUrl = args[1];
  
  if (!fs.existsSync(filePath)) {
    logger.error(`Error: File not found: ${filePath}`);
    process.exit(1);
  }

  try {
    const client = new IndexCPClient();
    logger.info(`Adding ${filePath} to buffer...`);
    await client.addFile(filePath);
    logger.info(`Uploading to ${serverUrl}...`);
    const uploadResults = await client.uploadBufferedFiles(serverUrl);
    logger.info(`Successfully uploaded ${filePath}`);
    
    // Display server filename if it differs from client name
    if (uploadResults) {
      const serverName = uploadResults[filePath];
      const basename = require('path').basename(filePath);
      if (serverName && serverName !== basename) {
        logger.info(`Server filename: ${serverName}`);
      }
    }
  } catch (error) {
    logger.error('Error uploading file:', error.message);
    process.exit(1);
  }
}

async function handleAdd(args) {
  const filePath = args[0];
  
  if (!filePath) {
    logger.error('Error: File path is required');
    logger.info('Usage: indexedcp add <file-path>');
    process.exit(1);
  }

  if (!fs.existsSync(filePath)) {
    logger.error(`Error: File not found: ${filePath}`);
    process.exit(1);
  }

  try {
    const client = new IndexCPClient();
    await client.addFile(filePath);
    logger.info(`File ${filePath} successfully added to buffer`);
  } catch (error) {
    logger.error('Error adding file:', error.message);
    process.exit(1);
  }
}

async function handleList(args) {
  const verbose = args.includes('-v') || args.includes('--verbose');
  
  try {
    const client = new IndexCPClient();
    const db = await client.initDB();
    const chunks = await db.getAll(client.storeName);
    
    if (chunks.length === 0) {
      logger.info('No files in buffer');
      return;
    }
    
    // Group chunks by file
    const fileMap = new Map();
    for (const chunk of chunks) {
      const fileName = chunk.fileName || 'unknown';
      if (!fileMap.has(fileName)) {
        fileMap.set(fileName, {
          fileName,
          chunks: [],
          totalSize: 0,
          encrypted: chunk.encrypted || false,
          session: chunk.session || null,
          retryMetadata: chunk.retryMetadata || null
        });
      }
      const fileInfo = fileMap.get(fileName);
      fileInfo.chunks.push(chunk);
      fileInfo.totalSize += chunk.data ? chunk.data.byteLength || chunk.data.length : 0;
    }
    
    logger.info(`\nIndexedDB Buffer Status:`);
    logger.info(`Total files: ${fileMap.size}`);
    logger.info(`Total chunks: ${chunks.length}`);
    logger.info('');
    
    // Sort files by name
    const files = Array.from(fileMap.values()).sort((a, b) => 
      a.fileName.localeCompare(b.fileName)
    );
    
    for (const file of files) {
      const sizeKB = (file.totalSize / 1024).toFixed(2);
      const encryptedFlag = file.encrypted ? 'üîí' : '  ';
      const sessionInfo = file.session ? ` [session: ${file.session.substring(0, 8)}...]` : '';
      
      logger.info(`${encryptedFlag} ${file.fileName}`);
      logger.info(`   ${file.chunks.length} chunk(s), ${sizeKB} KB${sessionInfo}`);
      
      if (verbose) {
        // Show chunk details
        const sortedChunks = file.chunks.sort((a, b) => (a.chunkIndex || a.seq || 0) - (b.chunkIndex || b.seq || 0));
        for (const chunk of sortedChunks) {
          const index = chunk.chunkIndex !== undefined ? chunk.chunkIndex : chunk.seq;
          const chunkSize = chunk.data ? (chunk.data.byteLength || chunk.data.length) : 0;
          const chunkSizeKB = (chunkSize / 1024).toFixed(2);
          const retryInfo = chunk.retryMetadata ? 
            ` [retries: ${chunk.retryMetadata.retryCount || 0}, next: ${new Date(chunk.retryMetadata.nextRetry).toLocaleTimeString()}]` : '';
          logger.info(`     - Chunk ${index}: ${chunkSizeKB} KB${retryInfo}`);
        }
      }
      
      // Show retry information if present
      if (!verbose && file.retryMetadata) {
        const hasRetries = file.chunks.some(c => c.retryMetadata && c.retryMetadata.retryCount > 0);
        if (hasRetries) {
          const maxRetries = Math.max(...file.chunks.map(c => c.retryMetadata?.retryCount || 0));
          logger.info(`   ‚ö†Ô∏è  Has failed uploads (max retries: ${maxRetries})`);
        }
      }
      
      logger.info('');
    }
    
    logger.info(`Use 'indexcp ls -v' for verbose chunk details\n`);
    
  } catch (error) {
    logger.error('Error listing buffer:', error.message);
    process.exit(1);
  }
}

async function handleUpload(args) {
  let serverUrl = null;
  let apiKey = null;
  let filesToAdd = [];
  
  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--server' && i + 1 < args.length) {
      serverUrl = args[i + 1];
      i++; // Skip the next argument since it's the server URL
    } else if (arg.startsWith('--server=')) {
      serverUrl = arg.split('=', 2)[1];
    } else if (arg === '--api-key' && i + 1 < args.length) {
      apiKey = args[i + 1];
      logger.warn('WARNING: Providing API key via command line is not recommended for security reasons.');
      logger.warn('Consider setting the INDEXCP_API_KEY environment variable instead.');
      i++; // Skip the next argument since it's the API key value
    } else if (arg.startsWith('--api-key=')) {
      apiKey = arg.split('=', 2)[1];
      logger.warn('WARNING: Providing API key via command line is not recommended for security reasons.');
      logger.warn('Consider setting the INDEXCP_API_KEY environment variable instead.');
    } else if (!serverUrl && (arg.startsWith('http://') || arg.startsWith('https://'))) {
      // Also support old format: indexcp upload <server-url> [files]
      serverUrl = arg;
    } else {
      // Any additional arguments are file paths to add and upload
      filesToAdd.push(arg);
    }
  }
  
  if (!serverUrl) {
    logger.error('Error: Server URL is required');
    logger.info('Usage: indexcp upload --server <server-url> [--api-key <key>] [file1] [file2] ...');
    logger.info('   or: indexcp upload <server-url> [--api-key <key>] [file1] [file2] ...');
    process.exit(1);
  }

  try {
    const client = new IndexCPClient({ apiKey });
    
    // Add any files specified on command line
    if (filesToAdd.length > 0) {
      logger.info(`Adding ${filesToAdd.length} file(s) to buffer...`);
      for (const filePath of filesToAdd) {
        if (!fs.existsSync(filePath)) {
          logger.error(`Error: File not found: ${filePath}`);
          process.exit(1);
        }
        await client.addFile(filePath);
        logger.info(`  Added: ${filePath}`);
      }
    }
    
    const uploadResults = await client.uploadBufferedFiles(serverUrl);
    
    logger.info('All buffered files uploaded successfully');
    
    // Display server filename mappings if any differ from client names
    if (uploadResults) {
      const differentFilenames = Object.entries(uploadResults).filter(
        ([clientName, serverName]) => serverName !== require('path').basename(clientName)
      );
      
      if (differentFilenames.length > 0) {
        logger.info('\nServer-determined filenames:');
        differentFilenames.forEach(([clientName, serverName]) => {
          logger.info(`  ${require('path').basename(clientName)} -> ${serverName}`);
        });
      }
    }
  } catch (error) {
    logger.error('Error uploading files:', error.message);
    process.exit(1);
  }
}

async function handleServer(args) {
  let port = 3000;
  let outputDir = process.cwd();
  let apiKey = null;
  let pathMode = 'sanitize'; // default mode
  
  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--api-key' && i + 1 < args.length) {
      apiKey = args[i + 1];
      logger.warn('WARNING: Providing API key via command line is not recommended for security reasons.');
      logger.warn('Consider setting the INDEXCP_API_KEY environment variable instead.');
      i++; // Skip the next argument since it's the API key value
    } else if (arg.startsWith('--api-key=')) {
      apiKey = arg.split('=', 2)[1];
      logger.warn('WARNING: Providing API key via command line is not recommended for security reasons.');
      logger.warn('Consider setting the INDEXCP_API_KEY environment variable instead.');
    } else if (arg === '--path-mode' && i + 1 < args.length) {
      pathMode = args[i + 1];
      if (!['sanitize', 'allow-paths', 'ignore'].includes(pathMode)) {
        logger.error('ERROR: --path-mode must be one of: sanitize, allow-paths, ignore');
        process.exit(1);
      }
      i++; // Skip the next argument since it's the path mode value
    } else if (arg.startsWith('--path-mode=')) {
      pathMode = arg.split('=', 2)[1];
      if (!['sanitize', 'allow-paths', 'ignore'].includes(pathMode)) {
        logger.error('ERROR: --path-mode must be one of: sanitize, allow-paths, ignore');
        process.exit(1);
      }
    } else if (!isNaN(parseInt(arg))) {
      port = parseInt(arg);
    } else {
      outputDir = arg;
    }
  }
  
  // Check environment variable for API key
  if (!apiKey && process.env.INDEXCP_API_KEY) {
    apiKey = process.env.INDEXCP_API_KEY;
    logger.info('Using API key from INDEXCP_API_KEY environment variable');
  }
  
  try {
    const server = new IndexCPServer({ port, outputDir, apiKey, pathMode });
    logger.info(`Path handling mode: ${pathMode}`);
    server.listen(port);
    
    // Handle graceful shutdown
    process.on('SIGINT', () => {
      logger.info('\nShutting down server...');
      server.close();
      process.exit(0);
    });
  } catch (error) {
    logger.error('Error starting server:', error.message);
    process.exit(1);
  }
}

function showHelp() {
  logger.info(`
indexedcp - Secure, resumable file transfer with IndexedDB buffering

Usage:
  indexedcp <file-path> <server-url>                  cp-style: upload file directly
  indexedcp add <file-path>                           Add a file to the buffer
  indexedcp ls [-v|--verbose]                         List buffered files and chunks
  indexedcp upload --server <server-url> [--api-key <key>] [file1] [file2] ...
                                                      Upload buffered files to server
                                                      Optionally add files in the same command
  indexedcp upload <server-url> [--api-key <key>] [file1] [file2] ...
                                                      Alternative upload syntax
  indexedcp server [port] [output-dir] [--api-key <key>] [--path-mode <mode>]
                                                      Start upload server (default port: 3000)
  indexedcp help                                      Show this help message

API Key Options:
  --api-key <key>     Specify API key (NOT recommended for security)
  Environment var:    Set INDEXCP_API_KEY environment variable (recommended)
  Auto-prompt:        If no API key provided, you will be prompted

Path Mode Options (Server):
  --path-mode ignore       (Default) Generate unique: <timestamp>_<random>_<full-path>.<ext>
                           Path separators ‚Üí _, other special chars ‚Üí -
  --path-mode sanitize     Strip all paths, use simple filenames with session tracking
  --path-mode allow-paths  Allow clients to create subdirectories (with security checks)

Examples:
  # cp-style command (simple and direct):
  indexedcp myfile.txt http://localhost:3000/upload
  
  # Check what's in the buffer:
  indexedcp ls
  indexedcp ls -v                              # Verbose: show all chunk details
  
  # Two-step workflow (add, then upload):
  indexedcp add ./myfile.txt
  indexedcp ls                                 # Check buffer before uploading
  indexedcp upload http://localhost:3000/upload
  
  # Single-step workflow with explicit upload command:
  indexedcp upload --server http://localhost:3000/upload ./myfile.txt
  indexedcp upload --server http://localhost:3000/upload ./file1.txt ./file2.txt
  
  # Alternative upload syntax (without --server flag):
  indexedcp upload http://localhost:3000/upload ./myfile.txt
  indexedcp upload http://localhost:3000/upload ./file1.txt ./file2.txt ./file3.txt
  
  # Start server with default settings (ignore mode - unique filenames):
  indexedcp server 3000 ./uploads
  
  # Start server with simple filenames (sanitize mode):
  indexedcp server 3000 ./uploads --path-mode sanitize
  
  # Start server allowing subdirectories (allow-paths mode):
  indexedcp server 3000 ./uploads --path-mode allow-paths
  
  # Using environment variable (recommended):
  export INDEXCP_API_KEY=your-api-key-here
  indexedcp myfile.txt http://localhost:3000/upload
  
  # Using command line (not recommended):
  indexedcp upload http://localhost:3000/upload --api-key your-key ./myfile.txt
`);
}

// Handle uncaught errors
process.on('unhandledRejection', (error) => {
  logger.error('Unhandled error:', error.message);
  process.exit(1);
});

if (require.main === module) {
  main().catch((error) => {
    logger.error('CLI error:', error.message);
    process.exit(1);
  });
}